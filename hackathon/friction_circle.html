<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Friction Circle - Driver Grip Analysis</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/d3-hexbin.v0.2.min.js"></script>
    <style>
        body {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 350px;
            padding: 20px;
            background: #252526;
            overflow-y: auto;
        }

        .chart-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        h1 {
            color: #4ec9b0;
            margin: 0 0 20px 0;
            font-size: 20px;
        }

        .controls {
            margin: 0 0 20px 0;
            padding: 15px;
            background: #2d2d2d;
            border-left: 4px solid #4ec9b0;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #4ec9b0;
            font-weight: bold;
        }

        select {
            width: 100%;
            background: #1e1e1e;
            color: #d4d4d4;
            border: 1px solid #4ec9b0;
            padding: 8px;
            font-family: inherit;
            font-size: 14px;
        }

        .stats {
            margin: 0;
            padding: 15px;
            background: #2d2d2d;
            border-left: 4px solid #ce9178;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .stat-item {
            background: #1e1e1e;
            padding: 10px;
            border-radius: 4px;
        }

        .stat-label {
            color: #858585;
            font-size: 12px;
        }

        .stat-value {
            color: #4ec9b0;
            font-size: 18px;
            font-weight: bold;
        }

        #chart {
            display: inline-block;
        }

        .hexagon {
            stroke: none;
        }


        .axis-label {
            font-size: 14px;
            fill: #d4d4d4;
        }

        .axis line, .axis path {
            stroke: #858585;
        }

        .axis text {
            fill: #d4d4d4;
        }

        .grid line {
            stroke: #3a3a3a;
            stroke-dasharray: 2,2;
        }

        #loading {
            text-align: center;
            padding: 40px;
            color: #4ec9b0;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h1>Friction Circle</h1>

            <div class="controls">
                <label for="driverSelect">Select Driver:</label>
                <select id="driverSelect">
                    <option value="">Loading...</option>
                </select>
            </div>

            <div class="stats">
                <strong>Driver Statistics</strong>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-label">Max Grip</div>
                        <div class="stat-value" id="maxGrip">--</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Samples</div>
                        <div class="stat-value" id="sampleCount">--</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Mean Total G</div>
                        <div class="stat-value" id="meanGrip">--</div>
                    </div>
                </div>
            </div>

            <div id="loading" style="margin-top: 20px; text-align: center; color: #4ec9b0;">Loading...</div>
        </div>

        <div class="chart-container">
            <div id="chart"></div>
        </div>
    </div>

    <script>
        // Polynomial fitting utilities
        function polynomialFit(x, y, degree) {
            // Least squares polynomial fit
            // Returns coefficients [a0, a1, a2, ..., an] for polynomial a0 + a1*x + a2*x² + ... + an*xⁿ
            const n = x.length;
            const m = degree + 1;

            // Build design matrix X and target vector Y
            const X = [];
            for (let i = 0; i < n; i++) {
                const row = [];
                for (let j = 0; j < m; j++) {
                    row.push(Math.pow(x[i], j));
                }
                X.push(row);
            }

            // Solve normal equations: (X^T X) * coeffs = X^T * y
            const XtX = matrixMultiply(matrixTranspose(X), X);
            const Xty = matrixVectorMultiply(matrixTranspose(X), y);

            return solveLinearSystem(XtX, Xty);
        }

        function polyEval(coeffs, x) {
            // Evaluate polynomial at x
            let result = 0;
            for (let i = 0; i < coeffs.length; i++) {
                result += coeffs[i] * Math.pow(x, i);
            }
            return result;
        }

        function matrixTranspose(A) {
            const rows = A.length;
            const cols = A[0].length;
            const result = [];
            for (let j = 0; j < cols; j++) {
                const row = [];
                for (let i = 0; i < rows; i++) {
                    row.push(A[i][j]);
                }
                result.push(row);
            }
            return result;
        }

        function matrixMultiply(A, B) {
            const rowsA = A.length;
            const colsA = A[0].length;
            const colsB = B[0].length;
            const result = [];
            for (let i = 0; i < rowsA; i++) {
                const row = [];
                for (let j = 0; j < colsB; j++) {
                    let sum = 0;
                    for (let k = 0; k < colsA; k++) {
                        sum += A[i][k] * B[k][j];
                    }
                    row.push(sum);
                }
                result.push(row);
            }
            return result;
        }

        function matrixVectorMultiply(A, v) {
            const rows = A.length;
            const cols = A[0].length;
            const result = [];
            for (let i = 0; i < rows; i++) {
                let sum = 0;
                for (let j = 0; j < cols; j++) {
                    sum += A[i][j] * v[j];
                }
                result.push(sum);
            }
            return result;
        }

        function solveLinearSystem(A, b) {
            // Gaussian elimination with partial pivoting
            const n = A.length;
            const augmented = A.map((row, i) => [...row, b[i]]);

            // Forward elimination
            for (let i = 0; i < n; i++) {
                // Partial pivoting
                let maxRow = i;
                for (let k = i + 1; k < n; k++) {
                    if (Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) {
                        maxRow = k;
                    }
                }
                [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];

                // Eliminate column
                for (let k = i + 1; k < n; k++) {
                    const factor = augmented[k][i] / augmented[i][i];
                    for (let j = i; j <= n; j++) {
                        augmented[k][j] -= factor * augmented[i][j];
                    }
                }
            }

            // Back substitution
            const x = new Array(n);
            for (let i = n - 1; i >= 0; i--) {
                x[i] = augmented[i][n];
                for (let j = i + 1; j < n; j++) {
                    x[i] -= augmented[i][j] * x[j];
                }
                x[i] /= augmented[i][i];
            }

            return x;
        }

        // Global data storage
        let allSamples = [];
        let envelopes = {};
        let currentDriver = null;

        // Chart dimensions
        const margin = { top: 40, right: 40, bottom: 60, left: 60 };
        const width = 800 - margin.left - margin.right;
        const height = 640 - margin.top - margin.bottom;

        // Load data (with cache-busting timestamp)
        const timestamp = Date.now();
        Promise.all([
            d3.csv(`data/processed/friction_circle_samples_corrected.csv?v=${timestamp}`),
            d3.json(`data/processed/friction_envelopes.json?v=${timestamp}`)
        ]).then(([samples, envelopeData]) => {
            // Parse samples
            allSamples = samples.map(d => ({
                vehicle: +d.vehicle_number,
                accx: +d.abs_accx,
                accy: +d.abs_accy
            }));

            envelopes = envelopeData;

            // Populate driver dropdown
            const vehicles = Array.from(new Set(allSamples.map(d => d.vehicle))).sort((a, b) => a - b);
            const select = d3.select('#driverSelect');

            select.selectAll('option').remove();
            select.selectAll('option')
                .data(vehicles)
                .enter()
                .append('option')
                .attr('value', d => d)
                .text(d => `Vehicle #${d}`);

            // Set initial driver
            currentDriver = vehicles[0];
            select.property('value', currentDriver);

            // Hide loading message
            d3.select('#loading').style('display', 'none');

            // Draw initial chart
            updateChart();

            // Add change listener
            select.on('change', function() {
                currentDriver = +this.value;
                updateChart();
            });
        }).catch(error => {
            console.error('Error loading data:', error);
            d3.select('#loading').html('Error loading data. Please ensure files exist in data/processed/');
        });

        function updateChart() {
            // Filter data for current driver
            const driverData = allSamples.filter(d => d.vehicle === currentDriver);
            const envelope = envelopes[currentDriver.toString()] || [];

            // Update stats
            const maxGrip = d3.max(envelope, d => d.total_g_max) || 0;
            const meanGrip = d3.mean(driverData, d => Math.sqrt(d.accx ** 2 + d.accy ** 2)) || 0;

            d3.select('#maxGrip').text(maxGrip.toFixed(2) + 'g');
            d3.select('#sampleCount').text(driverData.length.toLocaleString());
            d3.select('#meanGrip').text(meanGrip.toFixed(2) + 'g');

            // Clear previous chart
            d3.select('#chart').selectAll('*').remove();

            // Create SVG
            const svg = d3.select('#chart')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Scales
            const xScale = d3.scaleLinear()
                .domain([0, 2.5])
                .range([0, width]);

            const yScale = d3.scaleLinear()
                .domain([0, 2.5])
                .range([height, 0]);

            // Add grid
            svg.append('g')
                .attr('class', 'grid')
                .call(d3.axisLeft(yScale)
                    .tickSize(-width)
                    .tickFormat(''))
                .call(g => g.select('.domain').remove());

            svg.append('g')
                .attr('class', 'grid')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(xScale)
                    .tickSize(-height)
                    .tickFormat(''))
                .call(g => g.select('.domain').remove());

            // Create hexbin generator
            const hexbin = d3.hexbin()
                .x(d => xScale(d.accx))
                .y(d => yScale(d.accy))
                .radius(10)
                .extent([[0, 0], [width, height]]);

            // Generate hexbins
            const bins = hexbin(driverData);

            // Color scale
            const colorScale = d3.scaleSequential(d3.interpolateViridis)
                .domain([0, d3.max(bins, d => d.length)]);

            // Draw hexbins
            svg.append('g')
                .selectAll('path')
                .data(bins)
                .enter()
                .append('path')
                .attr('class', 'hexagon')
                .attr('d', hexbin.hexagon())
                .attr('transform', d => `translate(${d.x},${d.y})`)
                .attr('fill', d => colorScale(d.length))
                .attr('opacity', 0.8);

            // Compute envelopes using angular binning (like Python correction)
            const numAngleBins = 72; // 1.25° per bin for smoother envelope
            const angleBins = new Map(); // Map of angle bin -> array of {radius, accx, accy}

            // Convert to polar and collect by angle bin
            driverData.forEach(d => {
                const radius = Math.sqrt(d.accx ** 2 + d.accy ** 2);
                const angle = Math.atan2(d.accy, d.accx); // radians, 0 to π/2
                const binKey = Math.floor(angle / (Math.PI / 2) * numAngleBins);

                if (!angleBins.has(binKey)) {
                    angleBins.set(binKey, []);
                }
                angleBins.get(binKey).push({ radius, accx: d.accx, accy: d.accy, angle });
            });

            // Compute 99.5th percentile radius for each angular bin
            const p995EnvelopePoints = [];

            angleBins.forEach((points, binIdx) => {
                // Sort by radius descending
                points.sort((a, b) => b.radius - a.radius);

                if (points.length === 0) return;

                // Get 99.5th percentile radius
                const p995Index = Math.floor(points.length * 0.005); // top 0.5%
                const p995Radius = points[p995Index].radius;

                // Find representative angle for this bin
                const avgAngle = points.reduce((sum, p) => sum + p.angle, 0) / points.length;

                // Convert back to cartesian
                const p995Accx = p995Radius * Math.cos(avgAngle);
                const p995Accy = p995Radius * Math.sin(avgAngle);

                p995EnvelopePoints.push({ accx: p995Accx, accy: p995Accy });
            });

            // Sort by angle for proper rendering
            p995EnvelopePoints.sort((a, b) => Math.atan2(a.accy, a.accx) - Math.atan2(b.accy, b.accx));

            // Fit polynomial in polar coordinates: r = f(theta)
            // Convert envelope points to polar coordinates
            const polarPoints = p995EnvelopePoints.map(d => {
                const r = Math.sqrt(d.accx * d.accx + d.accy * d.accy);
                const theta = Math.atan2(d.accy, d.accx);
                return { r, theta, accx: d.accx, accy: d.accy };
            });

            // Sort by theta for fitting
            polarPoints.sort((a, b) => a.theta - b.theta);

            // Extract theta and r arrays for polynomial fitting
            const thetas = polarPoints.map(p => p.theta);
            const radii = polarPoints.map(p => p.r);

            // Fit 5th degree polynomial: r = a0 + a1*theta + a2*theta² + a3*theta³ + a4*theta⁴ + a5*theta⁵
            const degree = 5;
            const coeffs = polynomialFit(thetas, radii, degree);

            // Generate smooth curve points using the polynomial
            const curvePoints = [];
            for (let theta = 0; theta <= Math.PI / 2; theta += Math.PI / 180) { // 1° increments
                const r = polyEval(coeffs, theta);
                curvePoints.push({
                    accx: r * Math.cos(theta),
                    accy: r * Math.sin(theta)
                });
            }

            // Draw fitted curve in cyan
            const lineGenerator = d3.line()
                .x(d => xScale(d.accx))
                .y(d => yScale(d.accy))
                .curve(d3.curveLinear);

            svg.append('path')
                .datum(curvePoints)
                .attr('fill', 'none')
                .attr('stroke', 'cyan')
                .attr('stroke-width', 2)
                .attr('d', lineGenerator);

            // Draw 99.5th percentile envelope in blue
            svg.append('g')
                .selectAll('circle')
                .data(p995EnvelopePoints)
                .enter()
                .append('circle')
                .attr('cx', d => xScale(d.accx))
                .attr('cy', d => yScale(d.accy))
                .attr('r', 3)
                .attr('fill', 'blue')
                .attr('opacity', 0.9);

            // Add axes
            svg.append('g')
                .attr('class', 'axis')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(xScale).ticks(10));

            svg.append('g')
                .attr('class', 'axis')
                .call(d3.axisLeft(yScale).ticks(10));

            // Axis labels
            svg.append('text')
                .attr('class', 'axis-label')
                .attr('text-anchor', 'middle')
                .attr('x', width / 2)
                .attr('y', height + 45)
                .text('Longitudinal G (|accx|)');

            svg.append('text')
                .attr('class', 'axis-label')
                .attr('text-anchor', 'middle')
                .attr('transform', 'rotate(-90)')
                .attr('x', -height / 2)
                .attr('y', -45)
                .text('Lateral G (|accy|)');
        }
    </script>
</body>
</html>
