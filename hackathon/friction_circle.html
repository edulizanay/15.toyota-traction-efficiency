<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Friction Circle - Driver Grip Analysis</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/d3-hexbin.v0.2.min.js"></script>
    <style>
        body {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 350px;
            padding: 20px;
            background: #252526;
            overflow-y: auto;
        }

        .chart-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            position: relative;
        }

        .driver-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #2d2d2d;
            padding: 15px;
            border-left: 4px solid #4ec9b0;
            border-radius: 4px;
            min-width: 200px;
            z-index: 100;
        }

        .driver-overlay label {
            margin-bottom: 8px;
        }

        .driver-overlay select {
            width: 100%;
        }

        .driver-overlay .stats {
            margin: 15px 0 0 0;
            padding: 15px;
            background: #1e1e1e;
            border-left: 4px solid #ce9178;
        }

        h1 {
            color: #4ec9b0;
            margin: 0 0 20px 0;
            font-size: 20px;
        }

        .controls {
            margin: 0 0 20px 0;
            padding: 15px;
            background: #2d2d2d;
            border-left: 4px solid #4ec9b0;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #4ec9b0;
            font-weight: bold;
        }

        select {
            width: 100%;
            background: #1e1e1e;
            color: #d4d4d4;
            border: 1px solid #4ec9b0;
            padding: 8px;
            font-family: inherit;
            font-size: 14px;
        }

        .stats {
            margin: 0;
            padding: 15px;
            background: #2d2d2d;
            border-left: 4px solid #ce9178;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .stat-item {
            background: #1e1e1e;
            padding: 10px;
            border-radius: 4px;
        }

        .stat-label {
            color: #858585;
            font-size: 12px;
        }

        .stat-value {
            color: #4ec9b0;
            font-size: 18px;
            font-weight: bold;
        }

        #chart {
            display: inline-block;
        }

        .hexagon {
            stroke: none;
        }


        .axis-label {
            font-size: 14px;
            fill: #d4d4d4;
        }

        .axis line, .axis path {
            stroke: #858585;
        }

        .axis text {
            fill: #d4d4d4;
        }

        .grid line {
            stroke: #3a3a3a;
            stroke-dasharray: 2,2;
        }

        #loading {
            text-align: center;
            padding: 40px;
            color: #4ec9b0;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h1>Friction Circle</h1>

            <div class="controls">
                <label for="raceSelect">Select Race:</label>
                <select id="raceSelect">
                    <option value="R1">Race 1</option>
                    <option value="R2">Race 2</option>
                </select>
            </div>

            <div class="stats" style="margin-top: 20px;">
                <strong>Turn Zone Statistics</strong>
                <div id="zoneTable" style="margin-top: 10px;">
                    <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
                        <thead style="position: sticky; top: 0; background: #2d2d2d;">
                            <tr>
                                <th style="padding: 8px; text-align: left; border-bottom: 1px solid #4ec9b0;">Zone</th>
                                <th style="padding: 8px; text-align: right; border-bottom: 1px solid #4ec9b0;">Avg G</th>
                                <th style="padding: 8px; text-align: right; border-bottom: 1px solid #4ec9b0;">Util %</th>
                                <th style="padding: 8px; text-align: right; border-bottom: 1px solid #4ec9b0;">Samples</th>
                            </tr>
                        </thead>
                        <tbody id="zoneTableBody">
                            <tr><td colspan="4" style="padding: 8px; text-align: center;">--</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div id="loading" style="margin-top: 20px; text-align: center; color: #4ec9b0;">Loading...</div>
        </div>

        <div class="chart-container">
            <div class="driver-overlay">
                <label for="driverSelect">Select Driver:</label>
                <select id="driverSelect">
                    <option value="">Loading...</option>
                </select>

                <div class="stats">
                    <strong>Driver Statistics</strong>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div class="stat-label">Max Grip</div>
                            <div class="stat-value" id="maxGrip">--</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Samples</div>
                            <div class="stat-value" id="sampleCount">--</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-label">Mean Total G</div>
                            <div class="stat-value" id="meanGrip">--</div>
                        </div>
                    </div>
                </div>
            </div>
            <div id="chart"></div>
        </div>
    </div>

    <script>
        // Polynomial fitting utilities
        function polynomialFit(x, y, degree) {
            // Least squares polynomial fit
            // Returns coefficients [a0, a1, a2, ..., an] for polynomial a0 + a1*x + a2*x² + ... + an*xⁿ
            const n = x.length;
            const m = degree + 1;

            // Build design matrix X and target vector Y
            const X = [];
            for (let i = 0; i < n; i++) {
                const row = [];
                for (let j = 0; j < m; j++) {
                    row.push(Math.pow(x[i], j));
                }
                X.push(row);
            }

            // Solve normal equations: (X^T X) * coeffs = X^T * y
            const XtX = matrixMultiply(matrixTranspose(X), X);
            const Xty = matrixVectorMultiply(matrixTranspose(X), y);

            return solveLinearSystem(XtX, Xty);
        }

        function polyEval(coeffs, x) {
            // Evaluate polynomial at x
            let result = 0;
            for (let i = 0; i < coeffs.length; i++) {
                result += coeffs[i] * Math.pow(x, i);
            }
            return result;
        }

        function matrixTranspose(A) {
            const rows = A.length;
            const cols = A[0].length;
            const result = [];
            for (let j = 0; j < cols; j++) {
                const row = [];
                for (let i = 0; i < rows; i++) {
                    row.push(A[i][j]);
                }
                result.push(row);
            }
            return result;
        }

        function matrixMultiply(A, B) {
            const rowsA = A.length;
            const colsA = A[0].length;
            const colsB = B[0].length;
            const result = [];
            for (let i = 0; i < rowsA; i++) {
                const row = [];
                for (let j = 0; j < colsB; j++) {
                    let sum = 0;
                    for (let k = 0; k < colsA; k++) {
                        sum += A[i][k] * B[k][j];
                    }
                    row.push(sum);
                }
                result.push(row);
            }
            return result;
        }

        function matrixVectorMultiply(A, v) {
            const rows = A.length;
            const cols = A[0].length;
            const result = [];
            for (let i = 0; i < rows; i++) {
                let sum = 0;
                for (let j = 0; j < cols; j++) {
                    sum += A[i][j] * v[j];
                }
                result.push(sum);
            }
            return result;
        }

        function solveLinearSystem(A, b) {
            // Gaussian elimination with partial pivoting
            const n = A.length;
            const augmented = A.map((row, i) => [...row, b[i]]);

            // Forward elimination
            for (let i = 0; i < n; i++) {
                // Partial pivoting
                let maxRow = i;
                for (let k = i + 1; k < n; k++) {
                    if (Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) {
                        maxRow = k;
                    }
                }
                [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];

                // Eliminate column
                for (let k = i + 1; k < n; k++) {
                    const factor = augmented[k][i] / augmented[i][i];
                    for (let j = i; j <= n; j++) {
                        augmented[k][j] -= factor * augmented[i][j];
                    }
                }
            }

            // Back substitution
            const x = new Array(n);
            for (let i = n - 1; i >= 0; i--) {
                x[i] = augmented[i][n];
                for (let j = i + 1; j < n; j++) {
                    x[i] -= augmented[i][j] * x[j];
                }
                x[i] /= augmented[i][i];
            }

            return x;
        }

        // Global data storage
        let allSamples = [];
        let envelopes = {};
        let zoneStats = {};
        let currentDriver = null;
        let currentRace = 'R1';

        // Chart dimensions
        const margin = { top: 40, right: 40, bottom: 60, left: 60 };
        const width = 800 - margin.left - margin.right;
        const height = 640 - margin.top - margin.bottom;

        // Load data (with cache-busting timestamp)
        const timestamp = Date.now();
        // Try to load corrected envelopes first; fall back to raw if missing
        Promise.all([
            d3.csv(`data/processed/friction_circle_samples_corrected.csv?v=${timestamp}`),
            // Attempt corrected envelopes JSON first
            d3.json(`data/processed/friction_envelopes_corrected.json?v=${timestamp}`)
                .catch(() => d3.json(`data/processed/friction_envelopes.json?v=${timestamp}`)),
            d3.json(`data/processed/zone_statistics.json?v=${timestamp}`)
        ]).then(([samples, envelopeData, zoneStatsData]) => {
            // Parse samples
            allSamples = samples.map(d => ({
                vehicle: +d.vehicle_number,
                accx: +d.abs_accx,
                accy: +d.abs_accy
            }));

            envelopes = envelopeData;
            zoneStats = zoneStatsData;

            // Populate driver dropdown
            const vehicles = Array.from(new Set(allSamples.map(d => d.vehicle))).sort((a, b) => a - b);
            const select = d3.select('#driverSelect');

            select.selectAll('option').remove();
            select.selectAll('option')
                .data(vehicles)
                .enter()
                .append('option')
                .attr('value', d => d)
                .text(d => `Vehicle #${d}`);

            // Set initial driver
            currentDriver = vehicles[0];
            select.property('value', currentDriver);

            // Hide loading message
            d3.select('#loading').style('display', 'none');

            // Draw initial chart
            updateChart();

            // Add change listeners
            select.on('change', function() {
                currentDriver = +this.value;
                updateChart();
            });

            d3.select('#raceSelect').on('change', function() {
                currentRace = this.value;
                updateChart();
            });
        }).catch(error => {
            console.error('Error loading data:', error);
            d3.select('#loading').html('Error loading data. Please ensure files exist in data/processed/');
        });

        function updateChart() {
            // Filter data for current driver
            const driverData = allSamples.filter(d => d.vehicle === currentDriver);
            const envelopeData = envelopes[currentDriver.toString()] || null;
            const fieldEnvelopeData = envelopes["all"] || null;

            // Update stats
            let maxGrip = 0;
            if (envelopeData && envelopeData.envelope_points) {
                maxGrip = d3.max(envelopeData.envelope_points, d => d.total_g) || 0;
            }
            const meanGrip = d3.mean(driverData, d => Math.sqrt(d.accx ** 2 + d.accy ** 2)) || 0;

            d3.select('#maxGrip').text(maxGrip.toFixed(2) + 'g');
            d3.select('#sampleCount').text(driverData.length.toLocaleString());
            d3.select('#meanGrip').text(meanGrip.toFixed(2) + 'g');

            // Update zone statistics table (per race)
            const driverZones = (zoneStats[currentRace] && zoneStats[currentRace][currentDriver.toString()]) || [];
            const tbody = d3.select('#zoneTableBody');
            tbody.selectAll('*').remove();

            if (driverZones.length > 0) {
                driverZones.forEach(zone => {
                    const row = tbody.append('tr');
                    row.append('td')
                        .style('padding', '8px')
                        .style('border-bottom', '1px solid #3a3a3a')
                        .text(zone.zone_name);
                    row.append('td')
                        .style('padding', '8px')
                        .style('text-align', 'right')
                        .style('border-bottom', '1px solid #3a3a3a')
                        .style('color', '#4ec9b0')
                        .text(zone.avg_total_g.toFixed(2) + 'g');
                    row.append('td')
                        .style('padding', '8px')
                        .style('text-align', 'right')
                        .style('border-bottom', '1px solid #3a3a3a')
                        .style('color', '#ce9178')
                        .text((zone.avg_utilization * 100).toFixed(1) + '%');
                    row.append('td')
                        .style('padding', '8px')
                        .style('text-align', 'right')
                        .style('border-bottom', '1px solid #3a3a3a')
                        .style('color', '#858585')
                        .text(zone.sample_count.toLocaleString());
                });
            } else {
                tbody.append('tr')
                    .append('td')
                    .attr('colspan', '4')
                    .style('padding', '8px')
                    .style('text-align', 'center')
                    .text('No zone data');
            }

            // Clear previous chart
            d3.select('#chart').selectAll('*').remove();

            // Create SVG
            const svg = d3.select('#chart')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Scales
            const xScale = d3.scaleLinear()
                .domain([0, 2.5])
                .range([0, width]);

            const yScale = d3.scaleLinear()
                .domain([0, 2.5])
                .range([height, 0]);

            // Add grid
            svg.append('g')
                .attr('class', 'grid')
                .call(d3.axisLeft(yScale)
                    .tickSize(-width)
                    .tickFormat(''))
                .call(g => g.select('.domain').remove());

            svg.append('g')
                .attr('class', 'grid')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(xScale)
                    .tickSize(-height)
                    .tickFormat(''))
                .call(g => g.select('.domain').remove());

            // Create hexbin generator
            const hexbin = d3.hexbin()
                .x(d => xScale(d.accx))
                .y(d => yScale(d.accy))
                .radius(10)
                .extent([[0, 0], [width, height]]);

            // Generate hexbins
            const bins = hexbin(driverData);

            // Color scale
            const colorScale = d3.scaleSequential(d3.interpolateViridis)
                .domain([0, d3.max(bins, d => d.length)]);

            // Draw hexbins
            svg.append('g')
                .selectAll('path')
                .data(bins)
                .enter()
                .append('path')
                .attr('class', 'hexagon')
                .attr('d', hexbin.hexagon())
                .attr('transform', d => `translate(${d.x},${d.y})`)
                .attr('fill', d => colorScale(d.length))
                .attr('opacity', 0.8);

            // Draw field-wide envelope FIRST (as background reference)
            const fieldEnvelopePoints = fieldEnvelopeData && fieldEnvelopeData.envelope_points ?
                fieldEnvelopeData.envelope_points : [];
            const fieldCoeffs = fieldEnvelopeData && fieldEnvelopeData.poly_coeffs ?
                fieldEnvelopeData.poly_coeffs.slice().reverse() : null;

            console.log('Field envelope data:', fieldEnvelopeData ? 'exists' : 'missing');
            console.log('Field coeffs:', fieldCoeffs ? 'exists' : 'missing');
            console.log('Field envelope points:', fieldEnvelopePoints.length);

            if (fieldCoeffs) {
                const fieldCurvePoints = [];
                for (let theta = 0; theta <= Math.PI / 2; theta += Math.PI / 180) {
                    const r = polyEval(fieldCoeffs, theta);
                    fieldCurvePoints.push({
                        accx: r * Math.cos(theta),
                        accy: r * Math.sin(theta)
                    });
                }

                // Draw field-wide fitted curve in orange (background)
                const lineGenerator = d3.line()
                    .x(d => xScale(d.accx))
                    .y(d => yScale(d.accy))
                    .curve(d3.curveLinear);

                svg.append('path')
                    .datum(fieldCurvePoints)
                    .attr('fill', 'none')
                    .attr('stroke', '#ff8c42')  // orange
                    .attr('stroke-width', 4)
                    .attr('stroke-dasharray', '8,4')  // dashed line
                    .attr('opacity', 0.8)
                    .attr('d', lineGenerator);
            }

            // Draw field-wide envelope points in orange
            if (fieldEnvelopePoints.length > 0) {
                svg.append('g')
                    .selectAll('circle')
                    .data(fieldEnvelopePoints)
                    .enter()
                    .append('circle')
                    .attr('cx', d => xScale(d.accx))
                    .attr('cy', d => yScale(d.accy))
                    .attr('r', 2)
                    .attr('fill', '#ff8c42')  // orange
                    .attr('opacity', 0.4);
            }

            // Use pre-computed driver envelope points and polynomial coefficients
            const p995EnvelopePoints = envelopeData && envelopeData.envelope_points ?
                envelopeData.envelope_points : [];
            // Python np.polyfit returns descending order [a5,a4,...,a0], JavaScript polyEval expects ascending [a0,a1,...,a5]
            const coeffs = envelopeData && envelopeData.poly_coeffs ?
                envelopeData.poly_coeffs.slice().reverse() : null;

            // Generate smooth curve points using the polynomial
            if (coeffs) {
                const curvePoints = [];
                for (let theta = 0; theta <= Math.PI / 2; theta += Math.PI / 180) { // 1° increments
                    const r = polyEval(coeffs, theta);
                    curvePoints.push({
                        accx: r * Math.cos(theta),
                        accy: r * Math.sin(theta)
                    });
                }

                // Draw driver's fitted curve in cyan
                const lineGenerator = d3.line()
                    .x(d => xScale(d.accx))
                    .y(d => yScale(d.accy))
                    .curve(d3.curveLinear);

                svg.append('path')
                    .datum(curvePoints)
                    .attr('fill', 'none')
                    .attr('stroke', 'cyan')
                    .attr('stroke-width', 2)
                    .attr('d', lineGenerator);
            }

            // Draw driver's 99.5th percentile envelope in blue
            if (p995EnvelopePoints.length > 0) {
                svg.append('g')
                    .selectAll('circle')
                    .data(p995EnvelopePoints)
                    .enter()
                    .append('circle')
                    .attr('cx', d => xScale(d.accx))
                    .attr('cy', d => yScale(d.accy))
                    .attr('r', 3)
                    .attr('fill', 'blue')
                    .attr('opacity', 0.9);
            }

            // Add axes
            svg.append('g')
                .attr('class', 'axis')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(xScale).ticks(10));

            svg.append('g')
                .attr('class', 'axis')
                .call(d3.axisLeft(yScale).ticks(10));

            // Axis labels
            svg.append('text')
                .attr('class', 'axis-label')
                .attr('text-anchor', 'middle')
                .attr('x', width / 2)
                .attr('y', height + 45)
                .text('Longitudinal G (|accx|)');

            svg.append('text')
                .attr('class', 'axis-label')
                .attr('text-anchor', 'middle')
                .attr('transform', 'rotate(-90)')
                .attr('x', -height / 2)
                .attr('y', -45)
                .text('Lateral G (|accy|)');

            // Add legend at bottom-right
            const legend = svg.append('g')
                .attr('class', 'legend')
                .attr('transform', `translate(${width - 180}, ${height - 60})`);

            // Field envelope legend item
            legend.append('line')
                .attr('x1', 0)
                .attr('x2', 30)
                .attr('y1', 0)
                .attr('y2', 0)
                .attr('stroke', '#ff8c42')
                .attr('stroke-width', 4)
                .attr('stroke-dasharray', '8,4')
                .attr('opacity', 0.8);

            legend.append('text')
                .attr('x', 35)
                .attr('y', 4)
                .attr('fill', '#d4d4d4')
                .style('font-size', '12px')
                .text('Field Standard');

            // Driver envelope legend item
            legend.append('line')
                .attr('x1', 0)
                .attr('x2', 30)
                .attr('y1', 20)
                .attr('y2', 20)
                .attr('stroke', 'cyan')
                .attr('stroke-width', 2);

            legend.append('text')
                .attr('x', 35)
                .attr('y', 24)
                .attr('fill', '#d4d4d4')
                .style('font-size', '12px')
                .text(`Vehicle #${currentDriver}`);
        }
    </script>
</body>
</html>
