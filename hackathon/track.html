<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Traction Efficiency Analysis - Barber Motorsports Park</title>
    <style>
/* ABOUTME: Styling for traction efficiency analysis dashboard */
/* ABOUTME: Clean layout with full-screen track visualization */

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    background-color: #0a0a0a;
    color: #ffffff;
    overflow: hidden;
}

#header {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    padding: 20px 30px;
    background: linear-gradient(180deg, rgba(10,10,10,0.95) 0%, rgba(10,10,10,0) 100%);
    z-index: 1000;
    pointer-events: none;
    text-align: center;
}

#header h1 {
    font-size: 24px;
    font-weight: 600;
    margin-bottom: 5px;
    letter-spacing: -0.5px;
}

#header p {
    font-size: 14px;
    color: #999;
    font-weight: 400;
}

#track-container {
    width: 100vw;
    height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
}

#track-svg {
    width: 100%;
    height: 100%;
    cursor: move;
}

.track-surface {
    fill: #2a2a2a;
    stroke: #444;
    stroke-width: 1;
    stroke-linejoin: round;
}

.track-surface:hover {
    fill: #333;
}

#controls-panel {
    position: fixed;
    top: 80px;
    right: 30px;
    background: rgba(20, 20, 20, 0.95);
    border: 1px solid #333;
    border-radius: 8px;
    padding: 14px;
    width: 180px;
    max-height: calc(100vh - 140px);
    overflow-y: auto;
    z-index: 1000;
    backdrop-filter: blur(10px);
    pointer-events: auto;
}

.control-section {
    margin-bottom: 24px;
}

.control-section:last-child {
    margin-bottom: 0;
}

.control-section h3 {
    font-size: 12px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: #888;
    margin-bottom: 12px;
}


#button-panel {
    position: fixed;
    bottom: 30px;
    right: 30px;
    background: transparent;
    padding: 16px;
    width: 180px;
    z-index: 1000;
    pointer-events: auto;
    display: flex;
    flex-direction: column;
    align-items: center;
}

.control-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 65%;
    padding: 10px 14px;
    margin-bottom: 8px;
    background: transparent;
    border: 1px solid #d4a017;
    border-radius: 4px;
    color: #d4a017;
    font-size: 12px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
}

.control-btn:last-child {
    margin-bottom: 0;
}

.control-btn:hover {
    background: rgba(212, 160, 23, 0.1);
}

.control-btn.active {
    background: rgba(212, 160, 23, 0.15);
    border-color: #d4a017;
}

#race-selector {
    display: flex;
    gap: 6px;
    margin-bottom: 12px;
}

.race-btn {
    flex: 1;
    padding: 6px 10px;
    background: transparent;
    border: 1px solid #444;
    border-radius: 4px;
    color: #888;
    font-size: 11px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
}

.race-btn:hover {
    background: rgba(255, 255, 255, 0.05);
    border-color: #666;
}

.race-btn.active {
    background: rgba(212, 160, 23, 0.15);
    border-color: #d4a017;
    color: #d4a017;
}

#driver-list {
    display: flex;
    flex-direction: column;
    gap: 0px;
    max-height: 420px;
    overflow-y: auto;
}

.driver-item {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 2px 6px;
    background: transparent;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.driver-item:hover {
    background: rgba(255, 255, 255, 0.05);
}

.driver-item.active {
    background: rgba(255, 255, 255, 0.08);
}

.driver-item:not(.active) .driver-color {
    opacity: 0.3;
}

.driver-item.active .driver-color {
    opacity: 1;
}

.driver-item:not(.active) .driver-label {
    color: #666;
}

.driver-item.active .driver-label {
    color: #ffffff;
}

.driver-color {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    flex-shrink: 0;
    transition: opacity 0.2s ease;
}

.driver-label {
    font-size: 12px;
    font-weight: 500;
    flex: 1;
    transition: color 0.2s ease;
}

.driver-time {
    font-size: 10px;
    font-weight: 400;
    color: #888;
    transition: color 0.2s ease;
    font-family: 'Monaco', 'Courier New', monospace;
}

.driver-item.active .driver-time {
    color: #bbb;
}

.driver-item:not(.active) .driver-time {
    color: #555;
}

#legend-panel {
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 16px;
    background: rgba(20, 20, 20, 0.95);
    border: 1px solid #333;
    border-radius: 6px;
    padding: 8px 16px;
    z-index: 1000;
    backdrop-filter: blur(10px);
    pointer-events: auto;
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
}

.legend-color {
    width: 8px;
    height: 8px;
    border-radius: 2px;
}

.legend-color.optimal {
    background: #22c55e;
}

.legend-color.conservative {
    background: #eab308;
}

.legend-color.aggressive {
    background: #ef4444;
}

.legend-item span {
    font-size: 10px;
    font-weight: 500;
    color: #aaa;
}

/* Track chevron animations */
.track-chevrons {
    pointer-events: none;
}

.track-chevron {
    opacity: 0;
}

@keyframes chevronPulse {
    0% {
        opacity: 0;
    }
    10% {
        opacity: 0.5;
    }
    30% {
        opacity: 0.5;
    }
    40% {
        opacity: 0;
    }
    100% {
        opacity: 0;
    }
}
    </style>
</head>
<body>
    <div id="header">
        <h1>Barber Motorsports Park</h1>
        <p>← → Navigate zones with arrow keys</p>
    </div>

    <div id="controls-panel">
        <div class="control-section">
            <div id="race-selector">
                <button class="race-btn active" data-race="R1">R1</button>
                <button class="race-btn" data-race="R2">R2</button>
            </div>
        </div>
        <div class="control-section">
            <div id="driver-list">
                <!-- Drivers will be loaded dynamically -->
            </div>
        </div>
    </div>

    <div id="button-panel">
        <button id="toggle-corners" class="control-btn active">Corners</button>
        <button id="toggle-avg-events" class="control-btn active">Events</button>
    </div>

    <div id="legend-panel">
        <div class="legend-item">
            <div class="legend-color optimal"></div>
            <span>Optimal</span>
        </div>
        <div class="legend-item">
            <div class="legend-color conservative"></div>
            <span>Conservative</span>
        </div>
        <div class="legend-item">
            <div class="legend-color aggressive"></div>
            <span>Aggressive</span>
        </div>
    </div>

    <div id="track-container">
        <svg id="track-svg"></svg>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
// ABOUTME: D3.js visualization for Barber Motorsports Park track analysis
// ABOUTME: Renders track surface with boundaries and interactive zoom/pan

// Rotate coordinates using 2D rotation matrix
function rotateCoordinates(x, y, angleDegrees) {
    const angleRadians = (angleDegrees * Math.PI) / 180;
    const cos = Math.cos(angleRadians);
    const sin = Math.sin(angleRadians);
    return {
        x: x * cos - y * sin,
        y: x * sin + y * cos
    };
}

(async function() {
    // Load track boundaries and centerline
    const boundaries = await d3.json('data/processed/track_boundaries.json');
    const centerline = await d3.csv('data/processed/track_centerline.csv', d => ({
        x: +d.x_meters,
        y: +d.y_meters
    }));

    // Load pit lane
    const pitLane = await d3.json('data/processed/pit_lane.json');

    console.log(`Loaded track boundaries:`);
    console.log(`  Inner: ${boundaries.inner.length} points`);
    console.log(`  Outer: ${boundaries.outer.length} points`);
    console.log(`  Centerline: ${centerline.length} points`);
    console.log(`  Pit lane: ${pitLane.centerline.length} points`);

    // Rotate all coordinates around origin (negative = clockwise)
    const rotationAngle = -42;
    console.log(`Rotating track ${Math.abs(rotationAngle)}° clockwise`);

    // Rotate boundary points
    boundaries.inner = boundaries.inner.map(p => rotateCoordinates(p.x, p.y, rotationAngle));
    boundaries.outer = boundaries.outer.map(p => rotateCoordinates(p.x, p.y, rotationAngle));

    // Rotate centerline points
    centerline.forEach((p, i) => {
        const rotated = rotateCoordinates(p.x, p.y, rotationAngle);
        centerline[i].x = rotated.x;
        centerline[i].y = rotated.y;
    });

    // Rotate pit lane centerline
    pitLane.centerline = pitLane.centerline.map(p => {
        const rotated = rotateCoordinates(p.x_meters, p.y_meters, rotationAngle);
        return { x: rotated.x, y: rotated.y };
    });

    // Rotate pit lane boundaries
    if (pitLane.boundaries) {
        pitLane.boundaries.inner = pitLane.boundaries.inner.map(p => {
            const rotated = rotateCoordinates(p.x_meters, p.y_meters, rotationAngle);
            return { x: rotated.x, y: rotated.y };
        });
        pitLane.boundaries.outer = pitLane.boundaries.outer.map(p => {
            const rotated = rotateCoordinates(p.x_meters, p.y_meters, rotationAngle);
            return { x: rotated.x, y: rotated.y };
        });
    }

    // Set up SVG
    const svg = d3.select('#track-svg');
    const width = window.innerWidth;
    const height = window.innerHeight;

    svg.attr('width', width)
       .attr('height', height);

    // Create defs for checkered pattern
    const defs = svg.append('defs');

    // Checkered flag pattern (minimalistic racing start/finish)
    const squareSize = 0.5; // meters per square (larger squares)
    const checkerPattern = defs.append('pattern')
        .attr('id', 'checkerPattern')
        .attr('patternUnits', 'userSpaceOnUse')
        .attr('width', squareSize * 2)
        .attr('height', squareSize * 2);

    // Background matches track color to hide the line
    checkerPattern.append('rect')
        .attr('x', 0).attr('y', 0)
        .attr('width', squareSize * 2).attr('height', squareSize * 2)
        .attr('fill', '#2a2a2a'); // Same as track color

    checkerPattern.append('rect')
        .attr('x', 0).attr('y', 0)
        .attr('width', squareSize).attr('height', squareSize)
        .attr('fill', 'rgba(180, 180, 180, 0.6)'); // Light gray

    checkerPattern.append('rect')
        .attr('x', squareSize).attr('y', squareSize)
        .attr('width', squareSize).attr('height', squareSize)
        .attr('fill', 'rgba(180, 180, 180, 0.6)'); // Light gray

    // Create main group for zoom/pan
    const g = svg.append('g');

    // Calculate bounds from all boundary points
    const allPoints = [...boundaries.inner, ...boundaries.outer];
    const xExtent = d3.extent(allPoints, d => d.x);
    const yExtent = d3.extent(allPoints, d => d.y);

    const trackWidth = xExtent[1] - xExtent[0];
    const trackHeight = yExtent[1] - yExtent[0];

    // Add padding (10%)
    const padding = 0.1;
    const xPadding = trackWidth * padding;
    const yPadding = trackHeight * padding;

    // Create scales
    const xScale = d3.scaleLinear()
        .domain([xExtent[0] - xPadding, xExtent[1] + xPadding])
        .range([0, width]);

    const yScale = d3.scaleLinear()
        .domain([yExtent[0] - yPadding, yExtent[1] + yPadding])
        .range([height, 0]); // Invert Y axis (SVG coordinates)

    // Create closed polygon path
    // Go around outer edge clockwise, then inner edge counter-clockwise
    const outerClosed = [...boundaries.outer, boundaries.outer[0]];
    const innerReversed = [...boundaries.inner].reverse();
    const innerClosed = [...innerReversed, innerReversed[0]];

    // Combine into single polygon path
    const trackPolygon = [...outerClosed, ...innerClosed];

    // Line generator with curve smoothing for track
    const line = d3.line()
        .x(d => xScale(d.x))
        .y(d => yScale(d.y))
        .curve(d3.curveCatmullRom.alpha(0.5));

    // Smoother line generator for pit lane (higher alpha = smoother)
    const smoothLine = d3.line()
        .x(d => xScale(d.x))
        .y(d => yScale(d.y))
        .curve(d3.curveCatmullRom.alpha(0.8));

    // Draw pit lane FIRST (so it appears behind track)
    if (pitLane.boundaries) {
        const pitOuter = pitLane.boundaries.outer;
        const pitInnerReversed = [...pitLane.boundaries.inner].reverse();
        const pitLanePolygon = [...pitOuter, ...pitInnerReversed];

        g.append('path')
            .datum(pitLanePolygon)
            .attr('class', 'pit-lane-surface')
            .attr('d', smoothLine)
            .style('fill', '#2a2a2a')
            .style('stroke', '#444')
            .style('stroke-width', 1);
    }

    // Draw track surface SECOND (so it appears on top)
    g.append('path')
        .datum(trackPolygon)
        .attr('class', 'track-surface')
        .attr('d', line)
        .style('fill', '#2a2a2a')
        .style('stroke', '#444')
        .style('stroke-width', 1);

    // Load corner labels
    const cornerLabels = await d3.json('data/assets/corner_labels.json');
    console.log(`  Corner labels: ${cornerLabels.length} corners`);

    // Rotate corner label positions
    cornerLabels.forEach(corner => {
        const rotated = rotateCoordinates(corner.x_meters, corner.y_meters, rotationAngle);
        corner.x_meters = rotated.x;
        corner.y_meters = rotated.y;
    });

    // Calculate cumulative distances along centerline
    const centerlineWithDistance = [];
    let cumDistance = 0;

    for (let i = 0; i < centerline.length; i++) {
        if (i === 0) {
            centerlineWithDistance.push({ ...centerline[i], distance: 0 });
        } else {
            const prev = centerline[i - 1];
            const curr = centerline[i];
            const dx = curr.x - prev.x;
            const dy = curr.y - prev.y;
            const segmentDist = Math.sqrt(dx * dx + dy * dy);
            cumDistance += segmentDist;
            centerlineWithDistance.push({ ...curr, distance: cumDistance });
        }
    }

    // Calculate chevron positions along centerline
    function calculateChevronPositions(centerlineData, spacing_m = 75.0) {
        const positions = [];
        const totalDistance = centerlineData[centerlineData.length - 1].distance;

        // Sample positions every spacing_m meters
        for (let targetDist = 0; targetDist < totalDistance; targetDist += spacing_m) {
            // Find closest centerline point
            let closestIdx = 0;
            let minDiff = Math.abs(centerlineData[0].distance - targetDist);

            for (let i = 1; i < centerlineData.length; i++) {
                const diff = Math.abs(centerlineData[i].distance - targetDist);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestIdx = i;
                }
            }

            // Calculate tangent using central difference with wraparound
            const n = centerlineData.length;
            const prevIdx = (closestIdx - 5 + n) % n;
            const nextIdx = (closestIdx + 5) % n;

            const prev = centerlineData[prevIdx];
            const next = centerlineData[nextIdx];
            const curr = centerlineData[closestIdx];

            // Tangent vector
            let tx = next.x - prev.x;
            let ty = next.y - prev.y;
            const magnitude = Math.sqrt(tx * tx + ty * ty);

            if (magnitude > 1e-6) {
                tx /= magnitude;
                ty /= magnitude;

                // Calculate angle in degrees
                const angle = Math.atan2(ty, tx) * 180 / Math.PI;

                positions.push({
                    x: curr.x,
                    y: curr.y,
                    angle: angle,
                    distance: curr.distance
                });
            }
        }

        return positions;
    }

    // Create simple triangle arrow pointing in track direction
    function createChevronPath(x, y, angle, length_m = 4.0, width_m = 2.0) {
        const angleRad = angle * Math.PI / 180;
        const cos = Math.cos(angleRad);
        const sin = Math.sin(angleRad);

        // Chevron tip (front)
        const tipX = x + (length_m / 2) * cos;
        const tipY = y + (length_m / 2) * sin;

        // Base center (back)
        const baseX = x - (length_m / 2) * cos;
        const baseY = y - (length_m / 2) * sin;

        // Normal vector (perpendicular)
        const nx = -sin;
        const ny = cos;

        // Left and right base points
        const leftX = baseX + (width_m / 2) * nx;
        const leftY = baseY + (width_m / 2) * ny;
        const rightX = baseX - (width_m / 2) * nx;
        const rightY = baseY - (width_m / 2) * ny;

        // Return 3 points forming triangle
        return [
            { x: tipX, y: tipY },
            { x: leftX, y: leftY },
            { x: rightX, y: rightY }
        ];
    }

    // Add animated chevrons
    const markPositions = calculateChevronPositions(centerlineWithDistance, 80.0);
    console.log(`Calculated ${markPositions.length} chevron positions`);

    // Create chevrons group
    const marksGroup = g.append('g').attr('class', 'track-chevrons');

    // Animation settings
    const animationDuration = 3.0; // seconds
    const delayPerMark = animationDuration / markPositions.length;

    // Create chevrons at each position with staggered animations
    markPositions.forEach((pos, idx) => {
        // Create group of 3 chevrons at this position
        for (let chevIdx = 0; chevIdx < 3; chevIdx++) {
            const offset = chevIdx * 6; // 6m spacing between chevrons in a group

            // Calculate offset position along tangent
            const angleRad = pos.angle * Math.PI / 180;
            const offsetX = pos.x - offset * Math.cos(angleRad); // Negative offset for spacing behind
            const offsetY = pos.y - offset * Math.sin(angleRad);

            const points = createChevronPath(offsetX, offsetY, pos.angle, 4.0, 1.8);

            const pathData = `M ${xScale(points[0].x)},${yScale(points[0].y)} ` +
                           `L ${xScale(points[1].x)},${yScale(points[1].y)} ` +
                           `L ${xScale(points[2].x)},${yScale(points[2].y)} Z`;

            // Calculate animation delay for this chevron
            const animDelay = idx * delayPerMark;

            marksGroup.append('path')
                .attr('d', pathData)
                .attr('class', 'track-chevron')
                .attr('fill', '#444')
                .attr('stroke', 'none')
                .style('animation', `chevronPulse ${animationDuration}s linear infinite`)
                .style('animation-delay', `${animDelay}s`)
                .style('opacity', 0);
        }
    });

    console.log(`Track chevrons rendered (${markPositions.length * 3} total)`);

    // Draw checkered start/finish marker
    // Calculate track direction at start/finish using ±5 points
    const startIdx = 0;
    const prevIdx = Math.max(0, startIdx - 5);
    const nextIdx = Math.min(centerlineWithDistance.length - 1, startIdx + 5);

    const prevPoint = centerlineWithDistance[prevIdx];
    const nextPoint = centerlineWithDistance[nextIdx];
    const centerPoint = centerlineWithDistance[startIdx];

    // Calculate track angle in degrees
    const dx = nextPoint.x - prevPoint.x;
    const dy = nextPoint.y - prevPoint.y;
    const trackAngle = Math.atan2(dy, dx) * 180 / Math.PI;

    // Calculate track width at start/finish
    const innerPt = boundaries.inner[0];
    const outerPt = boundaries.outer[0];
    const startFinishTrackWidth = Math.sqrt(
        Math.pow(outerPt.x - innerPt.x, 2) +
        Math.pow(outerPt.y - innerPt.y, 2)
    );

    // Checkered flag dimensions
    const flagLength = 20.0; // 20m along track
    const flagWidth = startFinishTrackWidth * 0.95; // 95% of track width (5% smaller)

    // Calculate the perpendicular offset to center the flag on the track
    const perpAngle = (trackAngle + 90) * Math.PI / 180;
    const centerOffset = startFinishTrackWidth / 2;
    const flagCenterX = (innerPt.x + outerPt.x) / 2;
    const flagCenterY = (innerPt.y + outerPt.y) / 2;

    // Transform pattern to match data scale
    const patternScale = checkerPattern
        .attr('patternTransform', `scale(${1 / (xScale(1) - xScale(0))}, ${1 / (yScale(0) - yScale(1))})`);

    g.append('rect')
        .attr('class', 'checkered-start-finish')
        .attr('x', xScale(flagCenterX) - xScale(flagLength / 2) + xScale(0))
        .attr('y', yScale(flagCenterY) - (yScale(0) - yScale(flagWidth / 2)))
        .attr('width', xScale(flagLength) - xScale(0))
        .attr('height', yScale(0) - yScale(flagWidth))
        .attr('transform', `rotate(${trackAngle - 7.5}, ${xScale(flagCenterX)}, ${yScale(flagCenterY)})`)
        .style('fill', 'url(#checkerPattern)')
        .style('opacity', 0.9);

    // Draw corner labels
    const cornerLabelGroup = g.append('g').attr('class', 'corner-labels');

    cornerLabels.forEach(corner => {
        const labelGroup = cornerLabelGroup.append('g')
            .attr('transform', `translate(${xScale(corner.x_meters)}, ${yScale(corner.y_meters)})`);

        // Draw circle background
        labelGroup.append('circle')
            .attr('r', 18)
            .style('fill', 'transparent')
            .style('stroke', '#d4a017')
            .style('stroke-width', 2);

        // Draw corner number
        labelGroup.append('text')
            .attr('text-anchor', 'middle')
            .attr('dy', '0.35em')
            .style('fill', '#d4a017')
            .style('font-size', '14px')
            .style('font-weight', '600')
            .text(corner.label);
    });

    // Add zoom behavior
    const zoom = d3.zoom()
        .scaleExtent([0.5, 10])
        .on('zoom', (event) => {
            g.attr('transform', event.transform);
        });

    svg.call(zoom);

    // Initial zoom to fit
    const scale = 0.81 * Math.min(
        width / (trackWidth * (1 + 2 * padding)),
        height / (trackHeight * (1 + 2 * padding))
    );

    const centerX = (xExtent[0] + xExtent[1]) / 2;
    const centerY = (yExtent[0] + yExtent[1]) / 2;

    const translateX = width / 2 - xScale(centerX) * scale;
    const translateY = height / 2 - yScale(centerY) * scale;

    svg.call(zoom.transform, d3.zoomIdentity
        .translate(translateX, translateY)
        .scale(scale));

    console.log('Track visualization ready');

    // Load classified telemetry points
    const classifiedPoints = await d3.csv('data/processed/classified_telemetry_points.csv', d => ({
        race: d.race,
        vehicle_number: parseInt(d.vehicle_number),
        lap: parseInt(d.lap),
        zone_id: parseInt(d.zone_id),
        classification: d.classification,
        x: +d.x_meters,
        y: +d.y_meters
    }));

    console.log(`Loaded ${classifiedPoints.length} classified points`);

    // Rotate classified points
    classifiedPoints.forEach(p => {
        const rotated = rotateCoordinates(p.x, p.y, rotationAngle);
        p.x = rotated.x;
        p.y = rotated.y;
    });

    // Classification colors
    const classificationColors = {
        'Optimal': 'rgb(34, 197, 94)',      // green
        'Conservative': 'rgb(251, 191, 36)', // amber
        'Aggressive': 'rgb(239, 68, 68)'     // red
    };

    // Aggregate events by zone
    function aggregateEventsByZone(points, zoneCenterlinePositions) {
        const zoneMap = new Map();

        points.forEach(p => {
            if (!zoneMap.has(p.zone_id)) {
                zoneMap.set(p.zone_id, {
                    zone_id: p.zone_id,
                    Optimal: 0,
                    Conservative: 0,
                    Aggressive: 0,
                    count: 0
                });
            }

            const zone = zoneMap.get(p.zone_id);
            zone[p.classification]++;
            zone.count++;
        });

        // Use centerline positions and return array
        return Array.from(zoneMap.values())
            .filter(zone => zoneCenterlinePositions.has(zone.zone_id))
            .map(zone => {
                const pos = zoneCenterlinePositions.get(zone.zone_id);
                return {
                    zone_id: zone.zone_id,
                    centroid_x: pos.x,
                    centroid_y: pos.y,
                    Optimal: zone.Optimal,
                    Conservative: zone.Conservative,
                    Aggressive: zone.Aggressive,
                    total: zone.count
                };
            });
    }

    // Create group for classified points
    const classifiedPointsGroup = g.append('g').attr('class', 'classified-points');

    // Set up pie chart generators
    const pie = d3.pie()
        .value(d => d.value)
        .sort(null); // Don't sort, keep consistent order

    const arc = d3.arc()
        .innerRadius(0)
        .outerRadius(9); // 3x the original point radius (3 * 3 = 9)

    // Current state
    let currentRace = 'R1';
    let selectedDrivers = new Set();

    // Load drivers from friction envelopes
    const frictionEnvelopes = await d3.json('data/processed/friction_envelopes.json');
    const drivers = Object.keys(frictionEnvelopes).map(d => parseInt(d)).filter(d => d !== 0).sort((a, b) => a - b);

    console.log(`Loaded ${drivers.length} drivers:`, drivers);

    // Load driver best lap times (optional; show placeholders if missing)
    let driverBestLaps = {};
    try {
        driverBestLaps = await d3.json('data/processed/driver_best_laps.json');
    } catch (e) {
        console.warn('driver_best_laps.json missing or invalid; showing placeholders');
    }

    // Color scale for drivers
    const driverColors = [
        '#ffd700', '#888888', '#999999', '#777777', '#666666',
        '#aaaaaa', '#555555', '#bbbbbb', '#cccccc', '#444444',
        '#8888aa', '#999977', '#777788', '#666699', '#aaaacc',
        '#5555aa', '#bbbb77', '#cccc88', '#444499', '#8888bb'
    ];

    // Populate driver list
    const driverList = d3.select('#driver-list');

    // Add "All Drivers" option first
    driverList.append('div')
        .attr('class', 'driver-item')
        .attr('data-driver', 'all')
        .html(`
            <div class="driver-color" style="background: #ffd700;"></div>
            <span class="driver-label">All Drivers</span>
        `);

    // Add individual drivers
    drivers.forEach((driver, index) => {
        const color = driverColors[index % driverColors.length];
        const lapTime = driverBestLaps[driver.toString()] || '--:--';

        driverList.append('div')
            .attr('class', 'driver-item')
            .attr('data-driver', driver)
            .html(`
                <div class="driver-color" style="background: ${color};"></div>
                <span class="driver-label">#${driver}</span>
                <span class="driver-time">${lapTime}</span>
            `);
    });

    // Render function for classified points
    function renderClassifiedPoints() {
        // Get selected drivers
        selectedDrivers.clear();
        driverList.selectAll('.driver-item.active[data-driver]:not([data-driver="all"])')
            .each(function() {
                selectedDrivers.add(parseInt(d3.select(this).attr('data-driver')));
            });

        // Filter points by race and selected drivers
        const filteredPoints = classifiedPoints.filter(p => {
            const raceMatch = p.race === currentRace;
            const driverMatch = selectedDrivers.size === 0 || selectedDrivers.has(p.vehicle_number);
            return raceMatch && driverMatch;
        });

        // Aggregate by zone
        const zoneAggregates = aggregateEventsByZone(filteredPoints);

        console.log(`Rendering ${zoneAggregates.length} pie charts from ${filteredPoints.length} points (race: ${currentRace}, drivers: ${selectedDrivers.size})`);

        // Data join for zone groups
        const zoneGroups = classifiedPointsGroup.selectAll('g.zone-pie')
            .data(zoneAggregates, d => d.zone_id);

        // Exit
        zoneGroups.exit().remove();

        // Enter
        const entering = zoneGroups.enter()
            .append('g')
            .attr('class', 'zone-pie');

        // Update + Enter
        const allGroups = entering.merge(zoneGroups);

        // Position each group at zone centroid
        allGroups.attr('transform', d => `translate(${xScale(d.centroid_x)}, ${yScale(d.centroid_y)})`);

        // For each zone, create pie slices
        allGroups.each(function(zoneData) {
            const group = d3.select(this);

            // Prepare data for pie generator
            const pieData = [
                { classification: 'Optimal', value: zoneData.Optimal },
                { classification: 'Conservative', value: zoneData.Conservative },
                { classification: 'Aggressive', value: zoneData.Aggressive }
            ].filter(d => d.value > 0); // Only include non-zero slices

            // Data join for pie slices
            const slices = group.selectAll('path')
                .data(pie(pieData), d => d.data.classification);

            // Exit
            slices.exit().remove();

            // Enter
            slices.enter()
                .append('path')
                .attr('fill', d => classificationColors[d.data.classification])
                .attr('fill-opacity', 0.7)
                .attr('stroke', d => classificationColors[d.data.classification])
                .attr('stroke-width', 0.5)
                .merge(slices)
                .attr('d', arc);
        });
    }

    // Set up race selector
    d3.selectAll('.race-btn').on('click', function() {
        // Update active state
        d3.selectAll('.race-btn').classed('active', false);
        d3.select(this).classed('active', true);

        // Update current race
        currentRace = d3.select(this).attr('data-race');
        console.log(`Race changed to: ${currentRace}`);

        // Re-render points
        renderClassifiedPoints();
    });

    // Set up driver selector interactions
    driverList.selectAll('.driver-item').on('click', function() {
        const driverValue = d3.select(this).attr('data-driver');

        if (driverValue === 'all') {
            // Toggle all drivers
            const allDriverItems = driverList.selectAll('.driver-item[data-driver]:not([data-driver="all"])');
            const anyActive = allDriverItems.filter('.active').size() > 0;

            if (anyActive) {
                // Unmark all
                allDriverItems.classed('active', false);
                d3.select(this).classed('active', false);
                console.log('All drivers unmarked');
            } else {
                // Mark all
                allDriverItems.classed('active', true);
                d3.select(this).classed('active', true);
                console.log('All drivers marked');
            }
        } else {
            // Individual driver toggle
            const isActive = d3.select(this).classed('active');
            d3.select(this).classed('active', !isActive);

            // Update "All Drivers" state
            const allDriverItems = driverList.selectAll('.driver-item[data-driver]:not([data-driver="all"])');
            const allActive = allDriverItems.filter('.active').size() === allDriverItems.size();
            driverList.select('.driver-item[data-driver="all"]').classed('active', allActive);

            console.log(`Driver #${driverValue}: ${!isActive ? 'selected' : 'deselected'}`);
        }

        // Re-render points
        renderClassifiedPoints();
    });

    // Set up control button interactions
    d3.selectAll('.control-btn').on('click', function() {
        const isActive = d3.select(this).classed('active');
        d3.select(this).classed('active', !isActive);

        const buttonId = d3.select(this).attr('id');
        const buttonText = d3.select(this).text();
        console.log(`${buttonText}: ${!isActive ? 'ON' : 'OFF'}`);

        // Handle corner labels visibility
        if (buttonId === 'toggle-corners') {
            cornerLabelGroup.style('display', !isActive ? 'block' : 'none');
        }

        // Handle average events visibility
        if (buttonId === 'toggle-avg-events') {
            classifiedPointsGroup.style('display', !isActive ? 'block' : 'none');
        }
    });

    // Initial render
    renderClassifiedPoints();
    console.log('Classified points visualization ready');

    // ========================================
    // Zone Navigation System
    // ========================================

    // Load turn zones and calculate bounding boxes
    const turnZones = await d3.json('data/processed/turn_zones.json');
    console.log(`Loaded ${turnZones.length} turn zones`);

    // Calculate bounding box for each zone from classified points
    const ZONE_DATA = [];

    // Add "Full Track" view first
    ZONE_DATA.push({
        label: 'Full Track',
        xRange: [xExtent[0] - xPadding, xExtent[1] + xPadding],
        yRange: [yExtent[0] - yPadding, yExtent[1] + yPadding]
    });

    // Calculate bounds for each turn zone with minimum comfortable size
    const MINIMUM_ZONE_SIZE = 150; // meters - ensures enough context

    turnZones.forEach(zone => {
        const zonePoints = classifiedPoints.filter(p => p.zone_id === zone.zone_id);

        if (zonePoints.length > 0) {
            const xExtentZone = d3.extent(zonePoints, p => p.x);
            const yExtentZone = d3.extent(zonePoints, p => p.y);

            // Calculate natural dimensions
            let zoneWidth = xExtentZone[1] - xExtentZone[0];
            let zoneHeight = yExtentZone[1] - yExtentZone[0];

            // Apply minimum size constraint
            const effectiveWidth = Math.max(zoneWidth, MINIMUM_ZONE_SIZE);
            const effectiveHeight = Math.max(zoneHeight, MINIMUM_ZONE_SIZE);

            // Center the box around the original center
            const centerX = (xExtentZone[0] + xExtentZone[1]) / 2;
            const centerY = (yExtentZone[0] + yExtentZone[1]) / 2;

            const xMin = centerX - effectiveWidth / 2;
            const xMax = centerX + effectiveWidth / 2;
            const yMin = centerY - effectiveHeight / 2;
            const yMax = centerY + effectiveHeight / 2;

            // Add padding (20% of effective size)
            const zonePadding = 0.2;
            const xPaddingZone = effectiveWidth * zonePadding;
            const yPaddingZone = effectiveHeight * zonePadding;

            ZONE_DATA.push({
                label: zone.name,
                xRange: [xMin - xPaddingZone, xMax + xPaddingZone],
                yRange: [yMin - yPaddingZone, yMax + yPaddingZone]
            });
        }
    });

    console.log(`Zone navigation ready with ${ZONE_DATA.length} zones`);

    // State management
    let activeZoneIndex = 0;
    let isAnimating = false;

    // Smooth zoom animation using D3 transforms
    function smoothZoom(targetXRange, targetYRange, duration, callback) {
        const currentTransform = d3.zoomTransform(svg.node());

        // Calculate target transform from bounding box
        const targetScale = 0.95 * Math.min(
            width / (xScale(targetXRange[1]) - xScale(targetXRange[0])),
            height / (yScale(targetYRange[0]) - yScale(targetYRange[1]))
        );

        const targetCenterX = (targetXRange[0] + targetXRange[1]) / 2;
        const targetCenterY = (targetYRange[0] + targetYRange[1]) / 2;

        const targetTranslateX = width / 2 - xScale(targetCenterX) * targetScale;
        const targetTranslateY = height / 2 - yScale(targetCenterY) * targetScale;

        const targetTransform = d3.zoomIdentity
            .translate(targetTranslateX, targetTranslateY)
            .scale(targetScale);

        // Animation loop
        const startTime = performance.now();

        function step(currentTime) {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1.0);

            // Cubic ease-in-out
            const eased = progress < 0.5
                ? 4 * progress * progress * progress
                : 1 - Math.pow(-2 * progress + 2, 3) / 2;

            // Interpolate transform
            const k = currentTransform.k + (targetTransform.k - currentTransform.k) * eased;
            const x = currentTransform.x + (targetTransform.x - currentTransform.x) * eased;
            const y = currentTransform.y + (targetTransform.y - currentTransform.y) * eased;

            const interpolatedTransform = d3.zoomIdentity
                .translate(x, y)
                .scale(k);

            svg.call(zoom.transform, interpolatedTransform);

            if (progress < 1.0) {
                requestAnimationFrame(step);
            } else {
                if (callback) callback();
            }
        }

        requestAnimationFrame(step);
    }

    // Navigate to specific zone
    function navigateToZone(zoneIndex) {
        if (isAnimating || zoneIndex === activeZoneIndex) return;

        const zoneData = ZONE_DATA[zoneIndex];
        if (!zoneData) return;

        console.log(`Navigating to: ${zoneData.label}`);

        isAnimating = true;
        smoothZoom(zoneData.xRange, zoneData.yRange, 500, function() {
            activeZoneIndex = zoneIndex;
            isAnimating = false;
        });
    }

    // Keyboard event listener (left/right arrows only)
    document.addEventListener('keydown', function(e) {
        // Ignore if typing in input fields
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            return;
        }

        // Prevent animation queueing
        if (isAnimating) {
            return;
        }

        const maxIndex = ZONE_DATA.length - 1;
        let newIndex = activeZoneIndex;

        // Left/right arrow navigation with wrap-around
        if (e.key === 'ArrowRight') {
            newIndex = (activeZoneIndex + 1) % (maxIndex + 1);
            e.preventDefault();
        } else if (e.key === 'ArrowLeft') {
            newIndex = (activeZoneIndex - 1 + maxIndex + 1) % (maxIndex + 1);
            e.preventDefault();
        }

        if (newIndex !== activeZoneIndex) {
            navigateToZone(newIndex);
        }
    });

    console.log('Keyboard navigation active (← → to cycle through zones)');
})();
    </script>
</body>
</html>
